# 선택 정렬 : 기준 값 보다 더 작은 값 찾기
arr = [1, 5, 7, 3, 2, 5, 8, 9, 3, 9, 6, 4, 4, 2, 7]
for i in range(len(arr)):
    minIndex = i
    for j in range(i + 1, len(arr)):
        if arr[minIndex] > arr[j]:
            minIndex = j
    arr[i], arr[minIndex] = arr[minIndex], arr[i]
print(arr)

# 삽입 정렬 : 수를 앞으로 계속 밀어내기
arr2 = [1, 5, 7, 3, 2, 5, 8, 9, 3, 9, 6, 4, 4, 2, 7]
for i in range(len(arr2)):
    index = i
    while index > 0 and arr2[index-1] > arr2[index]:
        arr2[index-1], arr2[index] = arr2[index], arr2[index-1]
        index -= 1
print(arr2)

"""
1. O 표기법
   > 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법
   > √5/3 N^2 - log(N/2) + 16N + 7이라는 식에서 √5/3 N^2가 가장 빨리 수가 증가하고 상수를 떼면 N^2이 됨.
     그리고 이 알고리즘의 수행시간을 O(N^2)이라고 표기
   > N^2M + NM^2 + NlogM = O(N^2M + NM^2) => 한쪽이 빠르게 증가한다고 할수 없기 때문에 둘다 O에 표기
   > 42 = O(1) => 입력의 크기와 상관없이 항상 같은 시간이 걸림
2. 삽입 정렬과 선택 정렬 시간 복잡도
   > 삽입 정렬
     ㄴ 최선의 경우 처음부터 정렬 된 배열이면 원소가 제자리에 있기 때문에 while은 실행 즉시 종료 됨.
        이 경우 while 시간 복잡도는 O(1)이 됨 for문에 의해 시간 복잡도가 정해지기 때문에 수행 시간은 O(N)이 됨
     ㄴ 최악의 경우 역순으로 정렬 된 배열이면 숫자를 맨 앞으로 끌고가기 때문에 while의 복잡도는 O(N)이 되고,
        전체 복잡도는 O(N^2)가 됨
   > 임의의 순열이라고 할 때, 대부분에서 삽입 정렬이 선택 정렬보다 빠름. 삽입 정렬은 O(N^2) 정렬 중 가장 빠른 알고리즘
3. 분할 상환 분석
   > 시간 복잡도를 항상 반복문의 개수를 세는 것으로만 결정하지 않음. 문제에 따라 보다 정확한 시간 복잡도를 계산하는
     대표적인 예가 분할 상환 분석
   > 각 작업마다 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우, 전체 시간을 작업의 개수로 나눔
   > 분할 상환 분석은 동적 배열, 미나스 아노르의 해법에 사용
"""