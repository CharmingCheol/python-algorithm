# 퀵 정렬

1.정의
- O(N * N)의 시간복잡도인 삽입, 버블, 선택 정렬로 10만개의 데이터를 정렬하기엔 양이 너무 많음
- 퀵 정렬은 특정한 값을 기준으로 큰 숫자와 작은 숫자로 나눠서 분할 정복하는 정렬 기법
- 퀵 정렬에서 기준 값을 피벗이라고 부름. 즉, 피벗을 기준으로 왼쪽과 오른쪽으로 나눠서 정렬

2.퀵 정렬 동작 순서
- 피벗을 시작 지점으로 잡음
- 피벗 시작 지점 + 1 ~ 끝 지점까지 기준으로 두 가지 수의 경우를 찾음
  - 왼쪽 -> 오른쪽으로 갈때 최초에 피벗보다 큰 값
  - 오른쪽 ->왼쪽으로 갈 때 최초에 피벗보다 작은 값
- 큰 값에 인덱스가 작은 값에 인덱스보다 작은 경우, 큰 값과 작은 값의 위치를 교환
- 큰 값에 인덱스가 작은 값에 인덱스보다 클 경우, 피벗과 작은 값의 위치를 교환
- 피벗과 작은 값의 위치를 교환하면, 교환 기점으로 왼쪽과 오른쪽에 수들을 각각 정렬시킴
- 이를 계속 반복

3.동작 예시
- 3 7 8 1 5 9 6 10 2 4
  - 피벗 3
  - 왼쪽 -> 오른쪽으로 갈때는 3보다 큰 값 선택 : 7
  - 오른쪽 ->왼쪽으로 갈 때는 3보다 작은 값 선택 : 2
  - 7과 2를 선택하고 두 수의 위치를 교환
- 3 2 8 1 5 9 6 10 7 4
  - 피벗 3
  - 왼쪽 -> 오른쪽 이동하면서 3보다 큰 값 : 8
  - 오른쪽 -> 왼쪽 이동하면서 3보다 작은 값 : 1
  - 8과 1의 위치를 교환
- 3 2 1 8 5 9 6 10 7 4
  - 피벗 3
  - 왼쪽 -> 오른쪽 이동하면서 3보다 큰 값 : 8
  - 오른쪽 -> 왼쪽 이동하면서 3보다 작은 값 : 1
  - 작은 값에 인덱스가 큰 값의 인덱스보다 더 작기 때문에 엇갈리게 됨
  - 엇갈린 상황에서는 작은 값과 피벗의 위치를 교환(1 <-> 3)
- 1 2 3 8 5 9 6 10 7 4
  - 3은 정렬이 되었고, 3을 기준으로 왼쪽에는 3보다 작은 수가 위치
   오른쪽에 있는 3보다 큰 수들이 위치(분할되었다)
  - 양쪽으로 분할 된 부분에 대해 각각 퀵 정렬을 수행함.
   왼쪽 부분에서는 1이 피벗, 오른쪽 부분에서는 8이 피벗임
  - 1 기준해서 왼쪽부터 큰 값을 찾아서 2가 나오고, 오른쪽부터 작은 값을 찾아서 1이 나옴.
   엇갈린 상황이기 때문에 1과 1의 위치를 교환(즉, 제자리)
  - 남은 2도 위와 같은 과정을 반복해서 2의 위치를 확정시킴
- 1 2 3 8 5 9 6 10 7 4
  - 피벗 8
  - 왼쪽 -> 오른쪽 이동하면서 3보다 큰 값 : 9
  - 오른쪽 -> 왼쪽 이동하면서 3보다 작은 값 : 4
  - 9와 4의 위치를 교환
- 1 2 3 8 5 4 6 10 7 9
  - 피벗 8
  - 왼쪽 -> 오른쪽 이동하면서 3보다 큰 값 : 10
  - 오른쪽 -> 왼쪽 이동하면서 3보다 작은 값 : 7
  - 10과 7의 위치를 교환
- 1 2 3 8 5 4 6 7 10 9
  - 피벗 8
  - 왼쪽 -> 오른쪽 이동하면서 3보다 큰 값 : 10
  - 오른쪽 -> 왼쪽 이동하면서 3보다 작은 값 : 7
  - 엇갈렸기 때문에 8과 7의 위치를 교환
- 1 2 3 7 5 4 6 8 10 9
  - 8을 기준으로 작은 값에 대한 퀵 정렬, 큰 값에 대한 퀵 정렬을 각각 처리
- 계속 쭈우우우욱 진행하면 1 2 3 4 5 6 7 8 9 10순으로 정렬

4.코드
```python
def QuickSort(start, end):
    """
    start : 정렬을 수행하는 부분집합에서 첫번째 위치
    end : 정렬을 수행하는 부분집합엥서 마지막 위치
    """
    if start >= end: return  # 원소가 한개면 start가 end보다 크거나 같게 됨
    key = start  # 부분집합에서 첫번째 원소(피벗)
    i = start + 1  # 피벗 기준 우측 인덱스(왼쪽 출발 지점)
    j = end  # 마지막 범위(오른쪽 출발 지점)

    while i <= j:  # 좌, 우 인덱스가 엇갈릴 때 까지 반복
        while i <= end and data[i] <= data[key]:  # key 값보다 큰 값을 만날 때까지
            i += 1
        while j > start and data[j] >= data[key]:  # key 값보다 작은 값을 만날 때까지
            j -= 1
        if i > j:  # 엇갈린 상태라면 키 값과 교체
            temp = data[j]
            data[j] = data[key]
            data[key] = temp
        else:  # 엇갈리지 않았다면
            temp = data[i]
            data[i] = data[j]
            data[j] = temp
    QuickSort(start, j - 1)  # 왼쪽 부분 퀵 정렬
    QuickSort(j + 1, end)  # 오른쪽 부분 퀵 정렬


data = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9]
print(data)
QuickSort(0, len(data) - 1)
print(data) # 1 2 3 4 5 6 7 8 9 10
```

5.시간복잡도
- 퀵 정렬은 분할 정복 알고리즘으로 평균 시간 복잡도가 O(N * logN)이 나옴
- 하지만 치명적인 약점으로는 최악 시간 복잡도가 O(N * N)이 되는 경우도 있음
  - 이미 정렬되어 있는 경우에는 모든 자릿수를 순회하기 때문에, while문이 2번 반복 됨
- 그래서 데이터의 특성에 따라서 적절한 정렬 알고리즘을 채텍해야 됨

6.번외
- 만약 내림차순 정렬을 하고 싶다면 두개의 while 조건을 바꾸면 됨
```python
# <=을 >=으로 변경
while i <= end and data[i] >= data[key]:  # key 값보다 큰 값을 만날 때까지
    i += 1
# >=을 <=으로 변경
while j > start and data[j] <= data[key]:  # key 값보다 작은 값을 만날 때까지
    j -= 1
```