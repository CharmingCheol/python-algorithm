# LCS 알고리즘

## 1.정의
- Longest Common Subsequence의 줄임말로, 공통 부분 문자열 중 가장 길이가 긴 문자열을 찾는 알고리즘

## 2.Substring과 Subsequence
- LCS 알고리즘을 할 때 Substring과 Subsequence의 차이점을 알아야 됨
- LCSubstring(공통 부분 문자열) : 전체 문자열에서 연속된 부분 문자열
    ```python
     ABCDHEF -> Substring : 3(BCD)
     BCEDF
    ```
- LCSubsequence(공통 부분 수열) : 전체 문자열에서 꼭 연속된 문자열인 것은 아닌 부분 문자열
    ```python
     ABCDEF -> Subsequence : 3(ACD)
     AZGCDGHI
    ```

## 3.어떻게 비교할까?  
### 첫 행에서 문자열이 같을 때
|_|0|R|B|K|M|G|R|B|G|
|---|---|---|---|---|---|---|---|---|---|
|**0**|0|0|0|0|0|0|0|0|0|
|**B**|0|0|**1**|0|0|0|0|0|0|
- 맨 처음 B과 R을 비교한다. 서로 다르니 0으로 초기화
- R과 B를 비교했더니 동일함. 정확하게 말하면 RB와 B를 비교한거. 그러므로 공통 부분의 길이는 1

### 그 이후에는 첫 행의 나머지 열은 전부 1로 세팅
|_|0|R|B|K|M|G|R|B|G|
|---|---|---|---|---|---|---|---|---|---|
|**0**|0|0|0|0|0|0|0|0|0|
|**B**|0|0|**1**|**1**|**1**|**1**|**1**|**1**|**1**|
- 전부 1인 이유는 RB든, RBK든, RBKMG든 간에 B와 비교한다면, 결국 공통분모는 1이기 때문

## 문자열 끝 값이 서로 다른 경우
|_|0|R|B|K|M|G|R|B|G|
|---|---|---|---|---|---|---|---|---|---|
|**0**|0|0|0|0|0|0|0|0|0|
|**B**|0|0|1|1|1|1|1|1|1|
|**G**|0|0|1|0|0|0|0|0|0|
- G와 R은 다르다(BG와 R을 비교). 그러므로 0
- G와 B는 다르다(BG와 RB를 비교). 그런데 B라는 공통 분모가 있음
- 직전의 값(0)과 바로 위의 값(1)을 비교했을 때 다르다면, 더 큰 값을 현재 위치에 사용
- 즉, RB에서 B를 비교한 값과, BG에서 R를 비교했을 때 더 큰 값을 현재값으로 사용

# 직전 값과 위의 값이 같은 경우
|_|0|R|B|K|M|G|R|B|G|
|---|---|---|---|---|---|---|---|---|---|
|**0**|0|0|0|0|0|0|0|0|0|
|**B**|0|0|1|1|1|1|1|1|1|
|**G**|0|0|1|1|1|2|0|0|0|
- G와 G를 비교했는데 서로 같다(BG와 RBKMG을 비교). 여기서 공통 부분은 BG가 있음
- 문자열이 같다면 왼쪽 대각선 값에다가 1을 더해서 갱신한다

# 결과값은?
- 표에서 우측 하단에 있는 값이 LCS의 결과가 된다