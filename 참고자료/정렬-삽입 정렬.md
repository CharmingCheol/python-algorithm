# 삽입 정렬

1.정의
- 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결
- 여기서 "적절한 위치"라는 말이 핵심인데, 버블 정렬과 선택 정렬은 이미 정렬되어 있어도 무조건 위치를 바꾸는 형식이었음.
  그런데 삽입 정렬은 "필요할 때만"위치를 바꾸는 형식임

2.동작 과정
- 위에서 "적절한 위치"라는 말의 뜻은, 앞에 있는 수들이 이미 정렬되어 있다고 가정으로 전제함
- 1 10 5 8 7 6 4 3 2 9
  - _ 1 _ 10 5 8 7 6 4 3 2 9 -> 1 10 5 8 7 6 4 3 2 9
  - _ 1 _ 10 _ 5 8 7 6 4 3 2 9 -> 1 5 10 8 7 6 4 3 2 9
  - _ 1 _ 5 _ 10 _ 8 7 6 4 3 2 9 -> 1 5 8 10 7 6 4 3 2 9
- 자신의 수보다 왼쪽의 수가 더 크면 계속 위치를 바꿔주고, 자신의 수가 더 크면 반복문을 중단.
  그렇기 때문에 자신의 위치를 적절하게 찾아 갈 수 있음
  
3.코드
```python
array = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9]
temp = 0  # 배열에서 두 자리의 위치를 바꾸기 위해 사용하는 변수

for i in range(len(array) - 1):  # 전체 배열 길이에서 -1 한 만큼 반복
    j = i
    while array[j] > array[j + 1]:  # 자기가 index + 1에 있는 숫자보다 더 클 경우
        temp = array[j]
        array[j] = array[j + 1]
        array[j + 1] = temp
        j -= 1  # j 인덱스 1 감소
print(array)
```

4.시간복잡도
- 반복문이 두번 사용했기 때문에 O(N * N)이 됨.
- 하지만 "거의 정렬이 되었다고 가정"한다면 굉장히 빠른 속도를 자랑함.
  - 2 3 4 5 6 7 8 9 1
  - 2~9까지는 이미 정렬되었기 때문에 while 반복문이 실행되지 않음
  - 그리고 마지막에 있는 1에서만 while 반복문이 동작함
- "거의 정렬되었다고 가정"한다면 퀵 정렬, 힙 정려르 병합 정렬보다 빠르거나 동일한 속도를 자랑함.
- 이렇게 특정한 경우에는 굉장히 빠를 수 있기 때문에, 무조건으로 실행되는 선택 정렬과 버블 정렬보다 효율성이 좋은 O(N * N)정렬 알고리즘