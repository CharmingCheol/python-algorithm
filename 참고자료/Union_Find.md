# Union-Find

## 정의
- 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘

## 가정
- 여러개의 노드가 연결되어 있지 않은 경우에는, 각자 자기 자신만을 집합의 원소로 가짐.
- 즉, 모든 값이 자기 자신을 가리키게 됨
- 아래 표에서 첫 번째 행은 "노드 번호"를 의미하고, 두 번째 행은 "부모 노드 번호"를 뜻함

|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|
|1|2|3|4|5|6|7|8|

## 가정2
- 1과 2가 연결되어 있을 경우, 2번째 값은 1로 갱신
- 부모를 합칠 때 더 작은 값으로 합치며, 이를 Union이라고 함

|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|
|1|1|3|4|5|6|7|8|

# 가정3
- 2와 3이 연결된다면 아래와 같은 표가 된다. 그런데 의아한 점이라면 1과 3은 어떻게 연결되어 있는지 파악하지 안했다는 점

|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|
|1|1|2|4|5|6|7|8|
- 이를 해결하기 위해 3의 부모를 찾기 위해, 3이 가리키고 있는 2를 찾아 봄
- 2의 부모가 1을 가리키고 있으므로, 결과적으로 3도 부모가 1이 된다느 것을 알 수 있음
- 3의 부모를 갱신하기 위해 재귀를 걸면 아래와 같이 표가 갱신 됨

|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|
|1|1|1|4|5|6|7|8|


## 코드
```python
# 특정 노드의 부모 노드 찾기
def getParent(x):
    if arr[x] == x: return x  # 현재 노드가 부모의 노드가 같다면(자신을 가리킨다면)
    arr[x] = getParent(arr[x])  # 재귀로 자신의 부모 찾기
    return arr[x]

# 각 부모 노드를 합침. 더 작은 값으로 갱신
def unionParent(a, b):
    a = getParent(a)  # 부모 찾기
    b = getParent(b)  # 부모 찾기
    if a < b:
        arr[b] = a
    else:
        arr[a] = b

# 두 개의 노드가 같은 부모 노드를 가지는지 확인
def findParent(a, b):
    a = getParent(a)
    b = getParent(b)
    return True if a == b else False

# 처음에는 자신을 가리키도록 초기화
arr = [0] * 11
for i in range(1, 11):
    arr[i] = i

unionParent(1, 2)
unionParent(2, 3)
unionParent(3, 4)
unionParent(5, 6)
unionParent(6, 7)
unionParent(7, 8)
print(arr)  # [0, 1, 1, 1, 1, 5, 5, 5, 5, 9, 10]
print("1과 5 연결 여부", findParent(1, 5))  # False
unionParent(1, 5)
print("1과 5 연결 여부", findParent(1, 5))  # False
```