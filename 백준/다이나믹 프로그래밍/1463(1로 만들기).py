""" 플이과정

1.시행착오
 - 맨 처음에는 단순하게 3으로 최대한 많이 나누면 되는 줄 알았다. 2로 나누거나 1로 빼는 것보다 수가 더 빠르게 줄기 때문이다.
 - 그리고 3으로 나눠지지 않으면 2로 나누고, 2로도 나눠지지 않으면 1을 빼는 식으로 접근했다.

2.반례
 - 위 방법으로 한 결과 반례가 하나 있었다. 바로 10을 나누는 경우이다.
 - 10 -> 5 -> 4 -> 2 -> 1로 나눠지면서 5번을 반복하게 되지만, 문제에서는 10을 10 -> 9 -> 3 -> 1로 줄어든다.

3.어떻게 다시 접근할 것인가 -> Bottom Up DP
 - 2의 경우는 자명하게 1이다(1 -> 2).
 - 3의 경우는 다음과 같이 접근 할 수 있다
    > 1 -> 2 -> 3(2번), 1 -> 3(1번)
    > 최소 경우의 수를 확인해야 되기 때문에 3은 1의 값을 갖는다.
 - 공통(4 ~ ...)
    > 직전 인덱스에 접근하고 거기다가 1을 더해준다
    > 예시로 4인 경우 num[3] = 1이고, 거기다가 1을 더해줘서 num[4] = num[3] + 1로 저장한다
    > 이유는 연산조건 3번에서 1을 뺄 수 있다고 했는데, 역으로도 성립이 가능하기 때문
 - 2로 나눠서 떨어지는 경우(4, 6, 8...)
    > 공통 부분에서 진행한 경우의 수, 현재 인덱스에서 2를 나눈 인덱스의 값에다가 1을 더한다.
    > 2개 값 중에서 최솟값으로 현재 인덱스를 갱신한다
    > 예시로 8인 경우, dp[7] = 3을 저장하고 있다. 그리고 dp[8 // 2] = 2이고, 여기에다가 1을 더해준다.
      dp[7]와 dp[8 // 2] + 1을 비교했을 때, dp[8 // 2] + 1이 더 작기 때문에 dp[8] = 3으로 갱신한다
 - 3으로 나눠서 떨어지는 경우(6, 9, 12...)
   > 2로 나눠서 떨어지는 경우와 동일하게 진행한다.
 - 2나 3으로 모두 나눠서 떨어지는 경우(6, 12, 18, ...)
   > 2와 3으로 나눠지는 경우를 모두 진행한다
 - 2이나 3으로 나눠서 떨어지지 않는 경우(5, 7, 11, ...)
    > 특별한 동작이 더 없음

4.재수정(런타임 에러)
 - 인덱스 2, 3에다가 디폴트로 1을 박으면 될거라고 생각했다.
 - 그런데 배열의 크기가 1이거나 2일 때 dp[2] = 1, dp[3] = 1에서 런타임 에러가 발생한다
 - 이를 해결하기 위해 2, 3에 디폴트 값을 삭제했다. 어차피 반복문에서 연산되기 때문에...

5.결과
 - 0  1  2  3  4  5  6  7  8  9  10
   0  0  1  1  2  3  2  3  3  2   3

"""
import sys

num = int(sys.stdin.readline())
dp = [0] * (num + 1)

for index in range(2, num + 1):
    dp[index] = dp[index - 1] + 1
    # 현재 인덱스가 2로 나눠지고, 현재보다 더 최소의 있을 때
    if index % 2 == 0 and dp[index // 2] + 1 < dp[index]:
        dp[index] = dp[index // 2] + 1
    # 현재 인덱스가 3로 나눠지고, 현재보다 더 최소의 있을 때
    if index % 3 == 0 and dp[index // 3] + 1 < dp[index]:
        dp[index] = dp[index // 3] + 1
print(dp[num])